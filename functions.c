
/*
**************************************************************
 Файл с телами функций используемых в основной программе main
**************************************************************

*/

#include <functions.h> //; header
#include <Math.h> 				//для вычисления sqrt
#include <string.h>				 //работаем со строками



//----------------------------ФУНКЦИИ------------------------------------------

//--------DELAY-------

//тупая задержечка	 mks
 void delay( unsigned int length)	//в мкс
{
length=(length/2)-2; //тупо подобрал
while (length >0)
    length--;
}


//тупая задержечка  ms
 void delay_ms( unsigned int length)	//в ms
{
	length-=2;
	while (length >0)
    	{delay(1000);
		length--;
		}
}


//                          -------

//--------INIT SYSTEM-------

//Init system
 void init_system(void)
{
	LED = 0; //LED off
	P2 = 0xFF; //дискретные входы
	keys = 0xff; //все ключи отрубить
	adress|=(0x07<<4);	//все SPI устройства отключить
	
	//Приоритеты прерываний
	PS = 1;							//Приоритет прерывания по UART высокий
	PT2 = 1;					   //Приоритет прерывания по T2 высокий

	init_mempool (0x6fe, 255);  // инит для malloc. init_mempool (старт в xram,размер)
	

	/* CALIBRATION ADC */
	//adc(0xFF);

		/* PRECONFIGURE ADC */
	
	ADCCON1 = 0x0F8; // power up ADC/2 + 3 acq clock  ext_ref

}

//                          -------

//--------INIT T0-------

/*Init T0 для мигания светодиодом
 TT  = (2^n - Code)·TG ,
TT-Время переполнения
Code - начальный код в TH and TL
TG - период сигнала генератора (Tg=1/Fosc)=0.1mks
n – разрядность таймера

если начальный код=00, то время переполнения =0,1мкс*65535=5,9мс
*/

 void init_T0(void)
{
	TMOD = TMOD | 0x01 ;         /* Timer 0 in mode 2 
	16-битный таймер-счетчик, TH0 и TL0 включены последовательно. */
	TH0 = 0xFF;
	TL0 = 0xFE;
	ET0 = 1; //Enable interrupt of T0
	TR0 = 1;	 /* Timer 0 run */

}


//--------INIT T0 for ADC-------

/*Init T0 для задержки ADC при обработке переменки
 TT  = (2^n - Code)·TG ,
TT-Время переполнения
Code - начальный код в TH and TL
TG - период сигнала генератора (Tg=1/Fosc)=0.136mks
n – разрядность таймера

если начальный код=00, то время переполнения = 0,136мкс*65535 = 8913мкс
*/

 void init_T0_ADC(void)
{
	TMOD = TMOD | 0x01 ;         /* Timer 0 in mode 2 
	16-битный таймер-счетчик, TH0 и TL0 включены последовательно. */
	
	/* [65535-605мкс/0,13мкс] - вот это нач. значение таймера */
	TH0 = 0xED;	 //начальный код задержки 50ms/64 - 20mks(время преобразования)
	TL0 = 0xD2;
	ET0 = 0; //Diasable interrupt of T0
	TR0 = 0;	 /* Timer 0 run */

}
//                          -------

//--------INIT T2-------

/*Init T2 для отсчета времени разряда/заряда
дискретность 1 ms
 TT  = (2^n - Code)·TG ,
TT-Время переполнения
Code - начальный код в TH and TL
TG - период сигнала генератора (Tg=1/Fosc)=0.1mks
n – разрядность таймера

если начальный код=00, то время переполнения =0,1мкс*65535=5,9мс
*/

 void init_T2(void)
{
	RCLK=0;        
	CAP2=0;	    /* Timer 2- 16-Bit Capture */
	

	//настраиваем таймер на переполнение каждые 1ms
	TH2=0xE3; RCAP2H=0xE3;	   //RCAP2H	и RCAP2L в режиме 16-Bit Capture будут сами загружаться в TH2 and TL2
	TL2=0x47; RCAP2L=0x47;
	
	//обнуляем счетчик таймера Т2
	t2counter_ms = 0;
	
	ET2 = 1; //Enable interrupt of T0
	TR2 = 1;	 /* Timer 2 run */
}


//--------INIT UART-------

//Инициализация UART. Счетчик T1 
 void init_uart_t1(void)
{
	
	SCON = 0x50;					  /* uart in mode 1 (8 bit), REN=1 */
	TMOD = TMOD | 0x20 ;         /* Timer 1 in mode 2 */
	TH1  = 0xFE;                 /* 115 200 Bds at 11.0592MHz */
	TL1  = 0xFE; 				  	  /* 115 200 Bds at 11.0592MHz */
	ES = 1; 						     /* Enable serial interrupt	*/  //off for printf()
	EA = 1;						     /* Enable global interrupt */	//off for printf()
	TR1 = 1; 						  /* Timer 1 run */
	TI = 0;							  /* TI:   set TI to send first char of UART    */
	
}	
//                          -------

//--------INIT SPI-------

//Init system
 void init_SPI(void)
{
	SPE=1; //enable spi
	SPIM=1; //master mode
	CPOL=0; //Clock Polarity Select Bit.
	CPHA=1; //отправка данных по падению CLK
	SPR1=SPR0=0; //  Fosc / 2

}


//--------CRC-------
/*Вычисляем контрольную сумму CRС*/
/*Входные параметры: L-длина пакета, info[] - указатель на массив с 4-х байтовыми данными*/
/* запись info[] экивалентна *info */
 unsigned char CRC(unsigned char L, unsigned long int info[] )
{
	unsigned char i,tmp=0,L4;	
	
	L4=(L-2)/4;		//количество 4-х байтовых пакетов
					//(L-2) - минус байт L,минус байт код ответа
	
	/*-------Подсчет контрольной суммы CRC----------*/
	/* 		CRC = младший байт суммы (L+info)
			info = info[1..(N-1)]
	*/
	
	/*Сначала складываем байты в каждом 4-х байтовом элементе массива*/
	for (i=0;i<L4;i++)
	{
		tmp += info[i]; //сумма значений L+INFO
		
	}		
	tmp &= (~(0xFF00)) ; //зануляем старший байт
	return   tmp;
}
/*-----------------------------------------------*/




//--------PUT char to UART-------

//типа вывод числа char через УАРТ
/*+возвращает отправленный байт*/

unsigned char put(unsigned char c)
{
//	EA = 0; // запрещаем все прерывания нафиг
	SBUF = c;
	while (!TI); //Ожидание готовности
	TI = 0;	 //сбрасываем флаг
//	EA = 1; // разрешаем все прерывания 
	return c;

}

//--------PUT int to UART-------

//вывод четырех байт
/*+возвращает сумму отправленных байт для
подсчета CRC*/
unsigned char put_int(unsigned long int c)
{
	unsigned char i,CRC=0;
//	EA = 0; // запрещаем все прерывания нафиг

	for	(i=0;i<=24;i+=8)
	{
	CRC += (c>>(24-i)); //складываем байты для CRC
	SBUF = (c>>(24-i)); //выводим побайтно (>>24 >>16 >>8 >>0)
	while (!TI); //Ожидание готовности
	TI = 0;	 //сбрасываем флаг
	}
//	EA = 1; // разрешаем все прерывания 
	
	return CRC;

}

//--------PUT packet to UART-------

/*Вывод ответного пакета в УАРТ на верхний уровень

!!!ОДНО ОЧЕНЬ ИНТЕРЕСНОЕ УСЛОВИЕ!!!
!!!Функция работает с 4-х байтовыми пакетами array_data, если L>=7
!!!Функция работает с 1 байтовыми пакетами array_data, если L<7

предназначена в первую очередь для отправки ебанутых мкс,мкВ и мкА
Входные данные:
L-длина пакета
info[] - указатель на первый элемент массива array_data c данными для отправки */

void put_packet(unsigned char L,unsigned long int info[])
{
	unsigned char i,j=5,L4,L1,CRC=0;
	EA = 0; // запрещаем все прерывания нафиг

	/*ПОДГОТОВКА К ОТПРАВКЕ*/
	L4=(L-3)/4;				//количество 4-х байтовых пакетов для цикла отправки
							//(L-3) - минус байт L,минус байт код ответа, минус байт CRC
	
	L1=(L-3);				//количество 1 байтовых пакетов для цикла отправки
							//(L-3) - минус байт L,минус байт код ответа, минус байт CRC

	
 put_packet_repeat:

	CRC=L+0;			//набиваем CRC
	
	put (STX); 				//признак начала пакета
	put (L);				//длина пакета
	put (0);				//код ответа (см. ТЗ)

	//Работаем с байтовыми пакетами
	if (L<7) 
	 {
	 	/*отрыгиваем в УАРТ  по 1-му байту
		и заодно копим сумму для CRC*/
		for (i=0;i<L1;i++)	  //отправляем байты в соответствие с L4
		{
			CRC+=put( (unsigned char) info[i] ); 
	 	}
	  }
	else
	 {
	//Работаем с 4-х байтовыми пакетами
	/*Цикл для отправки 4-х байтовых пакетов массива array_data[]=info[] */
	for (i=0;i<L4;i++)	  //отправляем байты в соответствие с L4
	{
		/*отрыгиваем в УАРТ сразу по 4 байта
		и заодно копим сумму для CRC*/
		CRC+=put_int ( info[i] ); 
	}
	  }
	put (CRC);				 //CRC полетела в УАРТ. Конец пакета

	//*****************************************
	//	Устранение ошибок информационного обмена
	//*****************************************	
	//ждем ответ от ПК
	/*и считаем до 100 мс*/  
	i=100;
	while (!RI)
	{
		i--;
		if (i==0) goto put_packet_exit;	//если досчитали, то нафик выходим		  

	}		 

	/*Если не досчитали. то проверим, что пришло*/
	if (SBUF == ACK) {RI=0; goto put_packet_exit;} //если АСК, то выходим
	else if (SBUF == NAK) {  if((j--)!=0 ) {RI=0; goto put_packet_repeat;}  }	//если пришел NAK, то поторяем отправку 5 раз
//*****************************************	

 put_packet_exit:
	EA = 1; // разрешаем все прерывания 
}


//                          -------


//--------ADC-------

/*Функция выполняет преобразование выбранного канала ch,
Делаем 64 выборки за преиод (50мс). Время между выборками задается T0
преиод Т0=20мс/64=0,3125мс
Потом вычисляем RMS, а потом усредняем усредненое = AVG
Взовращаемое значение - напряжение на АЦП-DC	мВ
Входной параметр - номер канала
Выходной параметр - значение в мкВ, мкА
если ch==0xFF, то выполняем аппартную калибровку
 */
unsigned long int ADC(unsigned char ch)	//ch - номер канала
{
	#define X1 			32 					//количество усреднений
	#define X2 			4 					//количество усреднений по усредненным
	
	#define DC 			1.650		//постоянная составляющая, В
	
	#define LSB	   0.0008056640625 	//дискрета бортового АЦП (ref/2^12)  1LSB, В
	#define K_U220 		253.646 	//коэфф. передачи датчика по U_220	-> В
	#define K_I220 		1.500 		//коэфф. передачи датчика по I_220	-> А
	#define K_I15 		9.967 			//коэфф. передачи датчика по U_220 -> А
	
	#define delta 		0.012 			//погрешность В
	
	data unsigned char i=0,j=0;		//для циклов
	 unsigned  int buf[X1]=0; 		//массив для накопления кодов АЦП. Нужен для усреднения  
	 float  k=0,sum_rms=0; 				//sum-сумма для RMS  4-байтовое
	 float  N=0,sum_avg=0; 				//N-элемент суммы,sum-сумма для AVG  
	
	 unsigned long int  AVG=0; 		//среднее и СКЗ в В


//EA = 0; // запрещаем все прерывания нафиг

	
//-------------PRECONFIGURATION-------------------------
	
	/*INIT TIME0*/
	init_T0_ADC();

	/* CLEANING ADC */

	ADCI = 0; 					//обнуляем флаг готовности АЦП
	ADCDATAL= ADCDATAH=0x00; 	//обнулим нахер регистры данных АЦП,чтоб не серили	

	
	/* SELECT CHANNEL */
	ADCCON2 &= ~(0x0F);   		//обнуляем мл.4 бита для выбора канала
	ADCCON2 |= ch ;      		// select channel to convert
	
	//delay (2500); 				//задержечка 2,5мс для перезаряда sampling capacitor 32pF
//--------------------------------------------------

	
	
	
//----------------ПРЕОБРАЗОВАНИЕ----------------------------
		
		/*ЦИКЛ для нахождения среднего арифм.*/
		for (j=0;j<X2;j++)
		{	
		
			/* START CONVERSATION */
			i=0;
			
			/* НАКОПЛЕНИЕ ДАННЫХ В МАССИВ для СКЗ*/
			//время обработки+сдвиг 19,531 мкс
			while (i<X1)			//32 выборки
			{
				SCONV = 1;            						// begin single conversions
				
				while(SCONV==1) {/*ждемс конца преобразования...*/};
				
					buf[i] = (ADCDATAH<<8) + ADCDATAL; 		//копируем старшие 8 бит
					buf[i] &= ~(0x0F<<12);					//зануляем старшие 4 бита (там хранится номер канала)
					
					i++;
				
					/*Задержка 20мс/64 на таймере*/
					TH0 = 0xED;	 							//начальный код задержки 50ms/64 - 20mks(время преобразования)
					TL0 = 0xD2;
					TR0=1; 									//Timer0 RUN! 
					while(!TF0) {/*ждемс...*/};

					TR0=0;									//Timer0 STOP!
					TF0=0;  								//сброс флага
				
			}
		
	
			/* STOP CONVERSATION */
	
//--------------------------------------------------

//----------------ВЫЧИСЛЕНИЯ----------------------------
		
			/* СКЗ УСРЕДЕНЕНИЕ */
			for (i=0;i<X1;i++)
			{
				N= (buf[i]*LSB-DC);  //переводим в Вольты и вычитаем пост. сост.
				
				N=N*N;
				sum_rms += (  N  );  //  сумма для RMS: (код_АЦП*LSB-DC)^2
				 
			}
			sum_avg +=  sqrt(sum_rms/X1); 		//сумма для среднего арифм
			
			sum_rms=0;					  		//обнулим сумму для след.усреднения по СКЗ
		}
	   
	   
	   if (ch == 0) {k=K_U220;}		   			//если выбран ADC0
	   else if (ch == 1) {k=K_I220;}    		//если выбран ADC1
	   else if (ch == 2) {k=K_I15;}		 		//если выбран ADC2

	   AVG = (unsigned long int) ( ( (sum_avg/X2)) * k * 1000); //среднее по средним -> мВ,мА.
	    
	   
 init_T0(); 		//вернули мигание светодиода

//	EA=1; 		// разрешаем все прерывания 
return  (AVG*1000);	 //выходные данные -> мкВ, мкА
}




//--------DAC-------

//Установка DAC по SPI
 int DAC(unsigned long int value, unsigned char ch)	//(значение в мкВ,канал)
{
	 unsigned int d; //данные для DAC два байта

//EA=0; // запрещаем все прерывания нафиг
	
	/*подготовка данных*/
	d =	( value/(LSB_SPI*1000) );	//перевод мкВ в код ЦАП
 	d &= ~(0x0F<<12);		//затираем ненужные старшие 4 бита 

	SPI_TX (d,ch); //переадача по SPI в DAC
	
	delay(10);	//тупанем 10мкс для установки напряжения  ЦАП
//EA=1;
	return 0;
	
}
               


//--------Установка канала SPI-------
void set_CS (unsigned char CS)	//(номер CS),пример set_CS(CS1)
{

	P3 &= ~(0x07<<4);  //затираем адрес
	P3 |= (CS<<4);   //ставим адрес
	
}



//-----------DAC SPI------------------
//--------передача по SPI 2 байт-------
void SPI_TX (unsigned int d,unsigned char CS) // SPI_TX (данные, канал SPI)
{
	
	set_CS(CS);	 //установить адрес устройства
	
	SPIDAT =(d>>8);	  //отправили старший байт
	
	while (!ISPI); //ждем окончания передачи
	ISPI=0;
	
	SPIDAT =(d>>0);	 //отправили младший байт
	
	while (!ISPI); //ждем окончания передачи
	ISPI=0;
	
	set_CS (CS7); //сбросили канал SPI

}

//-----------ADC SPI-----------------
/*Процедура АЦП преобразования по SPI
входные параметры: in - номер входа (IN1 или IN2)
				   CS - устройство SPI
//возвращаемое значене функции - напряжение в мВ (мА)
Усреднение 16 раз  */
unsigned long int ADC_SPI (unsigned char in,unsigned char CS) //  (номер входа ADC, канал SPI)
{
	
#define K_U30V		6   // коэффициент делителя на АЦП U30V 
#define K_I30V		1   // коэффициент передачи ток-напряжение на АЦП I30V (мА-мВ)
#define K_U360V1	81
#define K_I360V1	0.2	// коэффициент передачи ток-напряжение на АЦП I360V2 (мА-мВ)

	
	unsigned char i=0;  		//для циклов
	float k=1;					//коэфф. передачи АЦП
	unsigned int d_adc=0;  		//принятые дынные с АЦП
 	unsigned int avg_adc=0;  	//усредненное значение АЦП
 	unsigned long int sum=0;  	//сумма для вычисления среднего

	unsigned long int v_adc=0;  //напряжение АЦП в мВ
	unsigned char d=0;  		//байт с номером входа ADC для отправки



	if (in == 1) {d=0;}	 		//IN1
	else if	(in == 2) {d=0x10;} //IN2
	
	//EA=0; 						// запрещаем все прерывания нафиг на время преобразования
	set_CS(CS);					 //установить адрес устройства
	
	/*1-е преобразование после power up по умолчанию по IN1*/
	/*2-е преобразование после power up по предустановленному каналу*/
	/*поэтому первое преобразование не учитываем, а предустанвливаем вход для след.*/
						
			SPIDAT =(d);	  	//отправили байт в control registr ADC
			while (!ISPI);   	//ждем окончания передачи
			ISPI=0;			 	//обнуляем флаг SPI
			SPIDAT =(d);	 	//отправили  байт
			while (!ISPI);   	//ждем окончания передачи
			ISPI=0;

		//понеслось преобразование
		for (i=1;i<=16;i++)
		{	
			d_adc=0; 			//обнуляем переменную для дальнейшей установки масок
		
			SPIDAT =(d);	  	//отправили байт в control registr ADC
	
			while (!ISPI); 		//ждем окончания передачи
			d_adc|=(SPIDAT<<8); //старшие 8 бит
			ISPI=0;			   //обнуляем флаг SPI
	
			SPIDAT =(d);	 	//отправили  байт
	
			while (!ISPI); 		//ждем окончания передачи
			d_adc|=(SPIDAT<<0); //младшие 8 бит
			ISPI=0;
			
			d_adc &= ~(0x0F<<12); 	//обнуляем старшие  незначащие 4 бита
			
			sum += (long int)d_adc; //копим сумму для среднего
		}		
	//EA=1;	
	
	set_CS (CS7); 					//сбросили канал SPI

	avg_adc = (int)(sum/(i-1)); 	//среднее арифм. по 64 выборкам
	
	/*Выбор коэффициента передачи АЦП в зависимости от выбранного канала*/
	if (CS == 4 && in==1) {k=K_U30V;}  							//если выбрано U30V (мерим напряжение по 30 В)
	else if (CS == 4 && in==2) {k=K_I30V;}						//если выбрано I30V	(мерим ток по 30 В)
	else if ( (CS == CS3 || CS == CS5) && in==1) {k=K_U360V1;}	//если выбрано U360V1 или U360V2 (мерим напр. по 360V1 или 360V2)
	else if ( (CS == CS3 || CS == CS5) && in==2) {k=K_I360V1;}	//если выбрано I360V1 или U360V2	(мерим ток по 360V1 или 360V2)

	v_adc = (long int) (avg_adc*LSB_SPI*k); 					// конверт код_АЦП->напряжение мВ (мА)

	return v_adc*1000; 												//возвращаемое значене функции - напряжение в мкВ (мкА)


}








//--------СТЕНД ИНФО-------
void info (void)
{
	const char* str1=" /*--------------------------------------------------*/\n";
	const char* str2=" Mehanotronika 2012\n Stend proverki istochnikov pitaniya SP-IP-U \n Version: v1.0 \n self-test: oK!\n\n";	
	const char* str3=" Developer: Tihonov E.\n tom-step@ya.ru\n";
	unsigned char len1,len2,len3; //длина строки
	unsigned char i,j=5; //i-длина строки, j-кол-во повторов отправки

	len1=strlen(str1); //вычисляем длину строки без \0
	len2=strlen(str2); //вычисляем длину строки без \0
	len3=strlen(str3); //вычисляем длину строки без \0
 
 info_repeat:
	//цикл1 для отправки строки1 в УАРТ
	for (i=0; i<len1; i++)
	{
		put (str1[i]); //отправляем посимвольно	
	}

	//цикл2 для отправки строки2 в УАРТ
	for (i=0; i<len2; i++)
	{
		put (str2[i]); //отправляем посимвольно	
	}
	//цикл3 для отправки строки3 в УАРТ
	for (i=0; i<len3; i++)
	{
		put (str3[i]); //отправляем посимвольно	
	}
	//цикл4 для отправки строки1 в УАРТ
	for (i=0; i<len1; i++)
	{
		put (str1[i]); //отправляем посимвольно	
	}


//*****************************************
//	Устранение ошибок информационного обмена
//*****************************************	
	//ждем ответ от ПК
	/*считаем до 100 мс*/  
	i=100;
	while (!RI)
	{
		i--;
		if (i==0) goto info_exit;			  

	}		 

	/*Проверем, что пришло*/
	if (SBUF == ACK) {goto info_exit;} //если АСК, то выходим
	else if (SBUF == NAK) {  if((j--)!=0 ) {RI=0; goto info_repeat;}  }	//если пришел NAK, то поторяем отправку 5 раз
//*****************************************	

 info_exit:
RI=0; //очищаем флаг приема
}





//--------ПОДАЧА/СНЯТИЕ ПИТАНИЯ-------

/*
Функция выполняет часть комманды №1 и №2 из ТЗ на ПрО

Входные параметры:
	key -код комманды (1-заряд,2-разряд) 
	U1 - флаг контроля 30В (1-да,0-нет)
	U2 - флаг контроля 360В1 (1-да,0-нет)
	U3 - флаг контроля 360В2 (1-да,0-нет)
	D1 - флаг контроля DIN1 (0-нет,1-30В_зам,2-360В1_зам,3-360В2_зам,4-30В_раз,5-360В1_раз,6-360В2_раз)
	D2 - флаг контроля DIN1 (0-нет,1-30В_зам,2-360В1_зам,3-360В2_зам,4-30В_раз,5-360В1_раз,6-360В2_раз)
	D3 - флаг контроля DIN1 (0-нет,1-30В_зам,2-360В1_зам,3-360В2_зам,4-30В_раз,5-360В1_раз,6-360В2_раз)
	D4 - флаг контроля DIN1 (0-нет,1-30В_зам,2-360В1_зам,3-360В2_зам,4-30В_раз,5-360В1_раз,6-360В2_раз)
	maxU1 - уставка 30В	  mkV
	maxU1 - уставка 360В1 mkV
	maxU1 - уставка 360В2 mkV

Выходные параметры(выводим через массив array_data):
	array_data[0] - Время нарастания напряжения на входе "Вх.30В" 	(mks)
	array_data[1] - Время нарастания напряжения на входе "Вх.360В1" (mks)
	array_data[2] - Время нарастания напряжения на входе "Вх.360В2" (mks)
	array_data[3] - Напряжение в момент замыкания или размыкания входа "Вх.Д1" (mkV)
	array_data[4] - Напряжение в момент замыкания или размыкания входа "Вх.Д2" (mkV)
	array_data[5] - Напряжение в момент замыкания или размыкания входа "Вх.Д3" (mkV)
	array_data[6] - Напряжение в момент замыкания или размыкания входа "Вх.Д4" (mkV)

	В случае зацикливания отправить сверху 0xFF;
	
*/
 void power_ON (unsigned char key,unsigned char U1,unsigned char U2,unsigned char U3,unsigned char D1,unsigned char D2,unsigned char D3,unsigned char D4,
 				unsigned long int maxU1,unsigned long int maxU2,unsigned long int maxU3)
{
	unsigned char	flag_U1,flag_U2,flag_U3,flag_D1,flag_D2,flag_D3,flag_D4; //для хранения копий полученых флагов. 	
	unsigned long int tmpADC=0;
	/*Сохраним полученные флаги в локальных переменных*/
	flag_U1 = U1;
	flag_U2 = U2;
	flag_U3 = U3;
	flag_D1 = D1;
	flag_D2 = D2;
	flag_D3 = D3;
	flag_D4 = D4;

	/*Обнуление используемых элементов массива для срача*/
	array_data[0]=0;
	array_data[1]=0;
	array_data[2]=0;
	array_data[3]=0;
	array_data[4]=0;
	array_data[5]=0;
	array_data[6]=0;
	


	/*Запускаем таймер*/
	init_T2();
	
	

	/*-Далее, в процессе разряда/заряда, будем сравнивать текущее значение
	напряжения с уставкой по тем каналам, флаги которых установлены. Как только 
	напряжение достигнет уставки, мы этот флаг сбрасываем, сохраняем текущее значение
	времени(мкс) в соответсвующий элемент массива array_data, и больше этот канал не мониторим.
	-Также будем мониторить (если есть флаг) состояние дискретных входов. Как только вход отработал,
	сразу сохраним текущее значение напряжения по нужному каналу (зависит от флага D), и очистим флаг*/
	
	while ( (flag_U1 == 1) || (flag_U2 == 1) || (flag_U3 == 1) || (flag_D1 > 0)||(flag_D2 > 0)||(flag_D3 > 0)||(flag_D4 > 0))  //делать, установлен, хотя бы один флаг по напряжению или DIN
	 {
		 tmpADC= ADC_SPI( 1,CS5 );

//Это кусок для тестирования д.Входов
/*		 if (tmpADC/1000 < 5000) {DOUT=OFF;}

		 tmpADC= ADC_SPI( 1,CS3 );
		 if (tmpADC/1000 < 5000) {DOUT=OFF;}

		 tmpADC= ADC_SPI( 1,CS5 );
		 if (tmpADC/1000 < 5000) {DOUT=OFF;}
*/


/*---------------------------------30В--------------------------*/
		if (flag_U1 == 1) 	
	 	{
	 		
			//сравнение текущего напяжения 30В с уставкой
			
			/*если key=1 - проверяем на заряд*/
			tmpADC= ADC_SPI( 1,CS0 );
			
			if (key == 1) 	{ if ( tmpADC > maxU1) 
							  {array_data[0]=(t2counter_ms*1000); flag_U1=0;} //если достигло, то сохранить время и очистить флаг
							
							} 
 			/*иначе разряд*/
			else  			{ if (tmpADC  < maxU1) 
							  {array_data[0]=(t2counter_ms*1000); flag_U1=0;} //если достигло, то сохранить время и очистить флаг
							
							}  
	 	}	
/*----------------------------***-------------------------------*/

		


/*-------------------------------360В1--------------------------*/
		if (flag_U2 == 1) 	
	 	{
	 		
			//сравнение текущего напяжения 360В1 с уставкой
			
			/*если key=1 - проверяем на заряд*/
			tmpADC= ADC_SPI( 1,CS3 );
			if (key == 1) 	{ if ( tmpADC > maxU2) 
							  {array_data[1]=(t2counter_ms*1000); flag_U2=0; } //если достигло, то сохранить время и очистить флаг
							
							} 
 			/*иначе разряд*/
			else  			{ if (tmpADC < maxU2) 
							  {array_data[1]=(t2counter_ms*1000); flag_U2=0;} //если достигло, то сохранить время и очистить флаг
							
							}  
	 	}	
/*---------------------------***----------------------------------*/


/*-------------------------------360В2--------------------------*/
		if (flag_U3 == 1) 	
	 	{
			tmpADC= ADC_SPI( 1,CS5 ); //измерение текущего значения напряжения
			
			//сравнение текущего напяжения 360В2 с уставкой
			/*если key=1 - проверяем на заряд*/
			if (key == 1) 	{ if ( tmpADC > maxU3) 
							  {array_data[2]=(t2counter_ms*1000); flag_U3=0; } //если достигло, то сохранить время и очистить флаг
							
							} 
 			/*иначе разряд*/
			else  			{ if (tmpADC < maxU3) 
							  {array_data[2]=(t2counter_ms*1000); flag_U3=0;} //если достигло, то сохранить время и очистить флаг
							
							}  
	 	}	
/*---------------------------***----------------------------------*/

	
		
	
	
		/******Проверка дискретных входов******/
		 	
			/*Возможные значение flag_DN:
			  	0-действие не выполнять
				1-контроль 30В, замыкание
				2-контроль 360В1, замыкание
				3-контроль 360В2, замыкание
				4-контроль 30В, размыкание
				5-контроль 360В1, размыкание
				6-контроль 360В2, размыкание*/


//---------------------------Контроль дискретного входа DIN1---------------------------------
			switch (flag_D1)
			 {
			 	//проверка на замыкание
				case 1:		if (DIN1 == 0) {array_data[3]=ADC_SPI(1,CS0); flag_D1=0; break; } 	else {break;} 	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 2:		if (DIN1 == 0) {array_data[3]=ADC_SPI(1,CS3); flag_D1=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 3:		if (DIN1 == 0) {array_data[3]=ADC_SPI(1,CS5); flag_D1=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				//проверка на размыкание
				case 4:		if (DIN1 == 1) {array_data[3]=ADC_SPI(1,CS0); flag_D1=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 5:		if (DIN1 == 1) {array_data[3]=ADC_SPI(1,CS3); flag_D1=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 6:		if (DIN1 == 1) {array_data[3]=ADC_SPI(1,CS5); flag_D1=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch

				default:	break;
			 }//switch (flag_D1)



//---------------------------Контроль дискретного входа DIN2---------------------------------
			switch (flag_D2)
			 {
			 	//проверка на замыкание
				case 1:		if (DIN2 == 0) {array_data[4]=ADC_SPI(1,CS0); flag_D2=0; break; } 	else {break;} 	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 2:		if (DIN2 == 0) {array_data[4]=ADC_SPI(1,CS3); flag_D2=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 3:		if (DIN2 == 0) {array_data[4]=ADC_SPI(1,CS5); flag_D2=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				//проверка на размыкание
				case 4:		if (DIN2 == 1) {array_data[4]=ADC_SPI(1,CS0); flag_D2=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 5:		if (DIN2 == 1) {array_data[4]=ADC_SPI(1,CS3); flag_D2=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 6:		if (DIN2 == 1) {array_data[4]=ADC_SPI(1,CS5); flag_D2=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch

				default:	break;
			 }//switch (flag_D2)


//---------------------------Контроль дискретного входа DIN3---------------------------------
			switch (flag_D3)
			 {
			 	//проверка на замыкание
				case 1:		if (DIN3 == 0) {array_data[5]=ADC_SPI(1,CS0); flag_D3=0; break; } 	else {break;} 	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 2:		if (DIN3 == 0) {array_data[5]=ADC_SPI(1,CS3); flag_D3=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 3:		if (DIN3 == 0) {array_data[5]=ADC_SPI(1,CS5); flag_D3=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				//проверка на размыкание
				case 4:		if (DIN3 == 1) {array_data[5]=ADC_SPI(1,CS0); flag_D3=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 5:		if (DIN3 == 1) {array_data[5]=ADC_SPI(1,CS3); flag_D3=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 6:		if (DIN3 == 1) {array_data[5]=ADC_SPI(1,CS5); flag_D3=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch

				default:	break;
			 }//switch (flag_D3)

//---------------------------Контроль дискретного входа DIN4---------------------------------
			switch (flag_D4)
			 {
			 	//проверка на замыкание
				case 1:		if (DIN4 == 0) {array_data[6]=ADC_SPI(1,CS0); flag_D4=0; break; } 	else {break;} 	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 2:		if (DIN4 == 0) {array_data[6]=ADC_SPI(1,CS3); flag_D4=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 3:		if (DIN4 == 0) {array_data[6]=ADC_SPI(1,CS5); flag_D4=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				//проверка на размыкание
				case 4:		if (DIN4 == 1) {array_data[6]=ADC_SPI(1,CS0); flag_D4=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 5:		if (DIN4 == 1) {array_data[6]=ADC_SPI(1,CS3); flag_D4=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch
				case 6:		if (DIN4 == 1) {array_data[6]=ADC_SPI(1,CS5); flag_D4=0; break;} 	else {break;}	//сохранить напряжение, очистить флаг, иначе, выйти из switch

				default:	break;
			 }//switch (flag_D3)

	   	



	 	/*Аварийный выход из процедуры по команде сверху. На случай зацикливания*/
		if (RI==1) 
		{    
			RI=0;				//обнуляем флаг приема
			if (SBUF == 0xFF)  //если пришел байт FF,вываливаемся из процедуры
			{
				flag_U1=flag_U2=flag_U3=0;		//чтобы выйти сбросим флаги
				flag_D1=flag_D2=flag_D3=flag_D4=0;
				array_data[0]=array_data[1]=array_data[2]=array_data[3]=array_data[4]=array_data[5]=array_data[6]=0xFFFFFFFF; //пошла хуйня наверх
			}     
		}	 
	 
	 }  //while 
	 

	TR2=0;	//не забудем вырубить таймер2
	
}	
//**************************************************************



//--------------ПОДДЕРЖКА МОЩИ-----------------

/*
Функция выполняет ебанутую часть комманды №7 из ТЗ на ПрО,
а именно, поддерживает установленную мощность, путем измерения
текущего напряжния и рассчета нужного значения для ЦАПа.
Куприн будет гореть в аду за эту команду!

Входные параметры:
	power - мощность в мкВт 
	ch - номер канала (3-30V,4-360V1,5-360V2)

*/
 void power_DAC (unsigned long int power,unsigned char ch)
{
	
	unsigned long int	current;  //рассчитанное значение тока (мкА)
	unsigned long int	DAC_value;  //рассчитанное значение для DAC (мкВ)
	unsigned long int	U;  //измеренноые знач. напряж. (мВ)
	
	unsigned char	DAC_ch;  //номер канала DAC
	unsigned char	ADC_ch;  //номер канала ADC_SPI
	unsigned char	k_DAC;  //коэфф. ток-напряжение для DAC,см.MathCad
	
	/*Выбор каналов для АЦП и ЦАП*/
	switch (ch)
	{
		case 3:		DAC_ch=CS1;		  //30V
					ADC_ch=CS0;
					k_DAC=1;	//1A-1V				
					break;

		case 4:		DAC_ch=CS4;		 //360V1
					ADC_ch=CS3;
					k_DAC=5;	//1A-5V
					break;

		case 5:		DAC_ch=CS6;		 //360V2
					ADC_ch=CS5;
					k_DAC=5;	//1A-5V
					break;

		default:	DAC_ch=CS1;		  //если пришла хуйня, по дефолту 30V
					ADC_ch=CS0;
					k_DAC=1;	//1A-1V	
					break;

	}
	
		U = ADC_SPI(1,ADC_ch)/1000;	//напряжение, мкВ->мВ
		
		current= (power/U)  ;	//измерили U,посчитали нужный ток //mА 

		DAC_value =  current*k_DAC*1000;	//пересчитали ток-напряжение DAC //-> mkA
		DAC (DAC_value,DAC_ch);				//установили нужный ток

//Все, конец.
}

//-------------------------------------------------------------------------




//------------------------------КОНЕЦ ФУНКЦИИ---------------------------






