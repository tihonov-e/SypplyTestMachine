/*
******************16 июля 2012******************************************	
	Рабочая программа для работы с СП-ИП-У
************************************************************************
**************автор - Тихонов Е.Н.****************************
	
	-проц ADUC841
	-кварц 7.3728 Мгц
	-время такта 0,136 мкс
	-опорное напряжение 3.3V
	Используется модель памяти Large (XDATA). В
	файле START_AD.A51 надо установить "XRAMEN EQU 1",чтобы включить
	память XRAM (2k)								 

*****************************************************************
	Назначение файлов
	aduc841+.h  - хидер для АДУКА, я добавил биты портов
	START_AD.A51 - asm-овский файл, который создал сам компилятор
	main.c - главная прога
	functions.c - тела функций
	Delay_11.0592.c -тупые задержки для данного кварца
	p_time.ini - файл сценария отладчика Keil для подсчета времени 
	выполнения куска проги
*****************************************************************



	Работаем с прогой DELPHI или с терминалкой
*****************************************************************
	По УАРТУ сверху передаем пакет, а снизу выполняем команду. 
	
	Формат пакета [02] [L] [info] [CTX]
	ДЕЛАЕМ ВСЕ ПО ТЗ

	№команды
		0	$02$03$00$03 - info
			

		1	$02$26$01$info$CTX - Подача питания
			[02] [L] [код комманды] [i1 i2 i3 i4 i5 i6 i7 i8 i9 i10 i11 U1 U2 U3][CTX]
		
		2	$02$06$02$00$64$05$CTX - установить напряжение(мВ) DAC в выбранном канале(CS)
			[02] [L] [код комманды] [ст.бит] [мл. бит.] [CS][CTX]
	
		3	$02$05$03$01$04$CTX - измерение АЦП по SPI
			[02][L] [код комманды] [номер входа] [CS(Yn)] [CTX]
		
		4	$02$05$04$00$00$00 - врубить/отрубить ключ
			[02][L] [код комманды] [on-0/off-1] [номер ключа(Yn)][CTX]

						 Yn
			ON_U1       7
			ON_U2       6
			ON_I1       5
			ON_I2       4
			DOUT       	3
			KZ_30V      2	
			KZ_360V1    1	
			KZ_360V2    0
			
			0xFF - отрубить все ключи

Примечание: Yn - номер выхода соответствующей микросхемы (Y1 = 1, Y2 = 2 ...)

		5	$02$03$05$00 - запрос состояния дискретных входов
			[02][L] [код комманды][CTX]

*/

//=======================INCLUDE======================== 
 #include <functions.h> //; header

//=======================ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ========================
 unsigned char key_command=0xFF; //код принятой от компа команды
 unsigned char *uart_buf;	//указатель для буфера данных с UART
 unsigned long int  array_data[10]; //массив для всякой хуйни типа напряжения в мВ и время в мС
 unsigned long int  t2counter_ms=0; //счетчик прерываний по таймеру T2	нужен для передачи данных из ф-ии в основную прогу и в УАРТ
									 

 

//=======================ПРЕРЫВАНИЯ========================
 void timer0 (void) ;
 void UART_RX (void); 
 //void adc_int();


//==============================================START==============================================
void main(void)
{	

// ---------VARIABLES-----------
	
	//---------команда №7------------
	/*эти переменные нужны для поддержания мощности, в случае,
	если в команде №7 пришел запрос установить нагрузку по мощности*/
	unsigned long int	power; 		//значение мощности из команды №7
	unsigned char		power_30V=0,power_360V1=0,power_360V2=0;	//флаги каналов из комманды №7	0-off,1-on
	//					 power_30V->[флаг 30В]	   power_360V1->[флаг 360В1]	   power_360V2->[флаг 360В2]
																	
// ---------INIT-----------
	
	init_system(); //инициализация системы
	init_SPI();
	init_uart_t1(); // инит UART
	init_T0(); // инит T0

//==============================================ОТЛАДКА===============================================


//==============================================ОСНОВНОЙ ЦИКЛ===============================================

/*В цикле ждем переменную key_command и массив uart_buf с UART*/
   while(1)																  
	{	
		//выбор действия по комманде с UART
		switch (key_command)	   
		{


//---------------------------------ИНФОРМАЦИЯ О СТЕНДЕ (№0)------------------------------------------

			/*Вывод строки с инфой о стенде в UART*/
			case 0: 	ES=0;												//запрещаем нафик прерывания от UART
						info(); key_command=0xFF; free (uart_buf); 			//вывод информации о стенде
						ES=1;												//разрешаем прерывания от UART
						break; 	
//---------------------------------------------------------------------------------------------------
			



//---------------------------------ПОДАЧА ПИТАНИЯ (№1)-----------------------------------------------

			/*Подача питания на проверяемый блок*/
			case 1:	
						ES=0;							//запрещаем нафик прерывания от UART
			
						/**************сохранение принятых пороговых значений для напряжений*********** 
						********************(3 значения по 4 байта)***************************
						порог канала 30В(мкВ)	 порог 360В1(мкВ)	   порог 360В2(мкВ)
						uart_buf[13]			  uart_buf[17]		   uart_buf[21]
						uart_buf[14]   			  uart_buf[18]		   uart_buf[22]
						uart_buf[15]			  uart_buf[19]		   uart_buf[23]
						uart_buf[16]			  uart_buf[20]		   uart_buf[24]					
						******************************************************************************/
							
						/***сохраняем 4 байта уставки 30В в 0-й элемент массива для срача	,long int***/
						
						array_data[0] = 0;	//предварительно обнулим этот четырехбайтовый элемент  [00] [00] [00] [00]
	
						array_data[0] |= (unsigned long int) 	uart_buf[13]<<24; 	// uart_buf[13] -> [x] [] [] []
						array_data[0] |= (unsigned long int)	uart_buf[14]<<16;  	// uart_buf[14] -> [] [x] [] []
						array_data[0] |= (unsigned long int)	uart_buf[15]<<8;   	// uart_buf[15] -> [] [] [x] []
						array_data[0] |= (unsigned long int)	uart_buf[16]<<0;   	// uart_buf[16] -> [] [] [] [x]

						/***сохраняем 4 байта уставки 360В1 в 1-й элемент массива для срача	,long int***/
						
						array_data[1] = 0;	//предварительно обнулим этот четырехбайтовый элемент  [00] [00] [00] [00]
	
						array_data[1] |= (unsigned long int) 	uart_buf[17]<<24; 	// uart_buf[17] -> [x] [] [] []
						array_data[1] |= (unsigned long int)	uart_buf[18]<<16;  	// uart_buf[18] -> [] [x] [] []
						array_data[1] |= (unsigned long int)	uart_buf[19]<<8;   	// uart_buf[19] -> [] [] [x] []
						array_data[1] |= (unsigned long int)	uart_buf[20]<<0;   	// uart_buf[20] -> [] [] [] [x]

						/***сохраняем 4 байта уставки 360В2 во 2-й элемент массива для срача	,long int***/
						
						array_data[2] = 0;	//предварительно обнулим этот четырехбайтовый элемент  [00] [00] [00] [00]
	
						array_data[2] |= (unsigned long int) 	uart_buf[21]<<24; 	// uart_buf[21] -> [x] [] [] []
						array_data[2] |= (unsigned long int)	uart_buf[22]<<16;  	// uart_buf[22] -> [] [x] [] []
						array_data[2] |= (unsigned long int)	uart_buf[23]<<8;   	// uart_buf[23] -> [] [] [x] []
						array_data[2] |= (unsigned long int)	uart_buf[24]<<0;   	// uart_buf[24] -> [] [] [] [x]
						//*****************************************************************************************	
							
						if (uart_buf[2]==1) {ON_U1=ON;} //info_1, вкл. Вых.U1 
						if (uart_buf[3]==1) {ON_U2=ON;} //info_2, вкл. Вых.U2		 //работа с ключами
						if (uart_buf[4]==1) {ON_I1=ON;} //info_3, вкл. Вых.I1 
						if (uart_buf[5]==1) {ON_I2=ON;} //info_4, вкл. Вых.I2

						/***********Вызываем функцию мониторинга при подаче/снятии питания***************************/
						power_ON (key_command,   uart_buf[6],uart_buf[7],uart_buf[8],uart_buf[9],uart_buf[10],uart_buf[11],uart_buf[12],   array_data[0],array_data[1],array_data[2] );
						//*****************************************************************************************	
						
						
						/********************ОТВЕТНЫЙ ПАКЕТ ДЛЯ ВЕРХНЕГО УРОВНЯ************************************/
							/*	[STX] 
								[L=31] 
							  	[0] 
								[4 байта t_u1] [4 байта t_u2] [4 байта t_u3] [4 байта u_D1] [4 байта u_D2] [4 байта u_D3] [4 байта u_D4]
								[CRC]
							*/
								
						put_packet(31,&array_data);	//отрыгиваем в УАРТ целый пакет с данными
						free (uart_buf); 			//очищаем память под массив
						key_command=0xFF;  			//сброс кода команды
						ES=1;						//снова разрешаем прерывания от UART
						break;
//-------------------------------------------------------------------------------------------------------------------------



//---------------------------------СНЯТИЕ ПИТАНИЯ (№2)-----------------------------------------------

			/*Снятие питания с проверяемого блока*/
			case 2:	
						ES=0;							//запрещаем нафик прерывания от UART
						/**************сохранение принятых пороговых значений для напряжений*********** 
						********************(3 значения по 4 байта)***************************
						порог канала 30В(мкВ)	 порог 360В1(мкВ)	   порог 360В2(мкВ)
						uart_buf[13]			  uart_buf[17]		   uart_buf[21]
						uart_buf[14]   			  uart_buf[18]		   uart_buf[22]
						uart_buf[15]			  uart_buf[19]		   uart_buf[23]
						uart_buf[16]			  uart_buf[20]		   uart_buf[24]					
						******************************************************************************/
							
						/***сохраняем 4 байта уставки 30В в 0-й элемент массива для срача	,long int***/
						
						array_data[0] = 0;	//предварительно обнулим этот четырехбайтовый элемент  [00] [00] [00] [00]
	
						array_data[0] |= (unsigned long int) 	uart_buf[13]<<24; 	// uart_buf[13] -> [x] [] [] []
						array_data[0] |= (unsigned long int)	uart_buf[14]<<16;  	// uart_buf[14] -> [] [x] [] []
						array_data[0] |= (unsigned long int)	uart_buf[15]<<8;   	// uart_buf[15] -> [] [] [x] []
						array_data[0] |= (unsigned long int)	uart_buf[16]<<0;   	// uart_buf[16] -> [] [] [] [x]

						/***сохраняем 4 байта уставки 360В1 в 1-й элемент массива для срача	,long int***/
						
						array_data[1] = 0;	//предварительно обнулим этот четырехбайтовый элемент  [00] [00] [00] [00]
	
						array_data[1] |= (unsigned long int) 	uart_buf[17]<<24; 	// uart_buf[17] -> [x] [] [] []
						array_data[1] |= (unsigned long int)	uart_buf[18]<<16;  	// uart_buf[18] -> [] [x] [] []
						array_data[1] |= (unsigned long int)	uart_buf[19]<<8;   	// uart_buf[19] -> [] [] [x] []
						array_data[1] |= (unsigned long int)	uart_buf[20]<<0;   	// uart_buf[20] -> [] [] [] [x]

						/***сохраняем 4 байта уставки 360В2 во 2-й элемент массива для срача	,long int***/
						
						array_data[2] = 0;	//предварительно обнулим этот четырехбайтовый элемент  [00] [00] [00] [00]
	
						array_data[2] |= (unsigned long int) 	uart_buf[21]<<24; 	// uart_buf[21] -> [x] [] [] []
						array_data[2] |= (unsigned long int)	uart_buf[22]<<16;  	// uart_buf[22] -> [] [x] [] []
						array_data[2] |= (unsigned long int)	uart_buf[23]<<8;   	// uart_buf[23] -> [] [] [x] []
						array_data[2] |= (unsigned long int)	uart_buf[24]<<0;   	// uart_buf[24] -> [] [] [] [x]
						//*****************************************************************************************	

						if (uart_buf[2]==1) {ON_U1=OFF;} //info_1, выкл. Вых.U1 
						if (uart_buf[3]==1) {ON_U2=OFF;} //info_2, выкл. Вых.U2		 //работа с ключами
						if (uart_buf[4]==1) {ON_I1=OFF;} //info_3, выкл. Вых.I1 
						if (uart_buf[5]==1) {ON_I2=OFF;} //info_4, выкл. Вых.I2
			

						/***********Вызываем функцию мониторинга при подаче/снятии питания***************************/
						power_ON (key_command,uart_buf[6],uart_buf[7],uart_buf[8],uart_buf[9],uart_buf[10],uart_buf[11],uart_buf[12],   array_data[0],array_data[1],array_data[2] );
						//*****************************************************************************************	
						
						
						/********************ОТВЕТНЫЙ ПАКЕТ ДЛЯ ВЕРХНЕГО УРОВНЯ************************************/
							/*	[STX] 
								[L=31] 
							  	[0] 
								[4 байта t_u1] [4 байта t_u2] [4 байта t_u3] [4 байта u_D1] [4 байта u_D2] [4 байта u_D3] [4 байта u_D4]
								[CRC]
							*/
								
						put_packet(31,&array_data);	//отрыгиваем в УАРТ целый пакет с данными
						free (uart_buf); 			//очищаем память под массив
						key_command=0xFF;  			//сброс кода команды
						ES=1;						//снова разрешаем прерывания от UART
						break;
//-------------------------------------------------------------------------------------------------------------------------




//---------------------------------КОНТРОЛЬ U,I по ВХОДУ "ВХ.U" (№3)-----------------------------------------------

			case 3:		
						ES=0;					//запрещаем нафик прерывания от UART		 
						
						array_data[0]=ADC(0);	//check U_220 and save to array_data[0]
						array_data[1]=ADC(1);	//check I_220 and save to array_data[1]
												
							/********************ОТВЕТНЫЙ ПАКЕТ ДЛЯ ВЕРХНЕГО УРОВНЯ************************************/
							/*	[STX] 
								[L=11] 
							  	[0] 
								[4 байта U_220] [4 байта I_220]
								[CRC]
							*/
					    put_packet(11,&array_data);	//отрыгиваем в УАРТ целый пакет с данными
						
						free (uart_buf); 			//очищаем память под массив
						key_command=0xFF;  			//сброс кода команды
						ES=1;						//снова разрешаем прерывания от UART
						break;
//-------------------------------------------------------------------------------------------------------------------------
			 

//---------------------------------КОНТРОЛЬ I по ВХОДУ "ВХ.I" (№4)--------------------------------------------------------

			case 4:		
						ES=0;					//запрещаем нафик прерывания от UART		 
						
						array_data[0]=ADC(2);	//check I_15 and save to array_data[0]
												
							/********************ОТВЕТНЫЙ ПАКЕТ ДЛЯ ВЕРХНЕГО УРОВНЯ************************************/
							/*	[STX] 
								[L=7] 
							  	[0] 
								[4 байта I_15]
								[CRC]
							*/
					    put_packet(7,&array_data);	//отрыгиваем в УАРТ целый пакет с данными
						
						free (uart_buf); 			//очищаем память под массив
						key_command=0xFF;  			//сброс кода команды
						ES=1;						//снова разрешаем прерывания от UART
						break;
//-------------------------------------------------------------------------------------------------------------------------


//---------------------------------КОНТРОЛЬ U,I по ВХОДАМ "ВХ.30В" "ВХ.360В1" "ВХ.360В2" (№5)------------------------------
														 /*216 ms*/
			case 5:		
						ES=0;					//запрещаем нафик прерывания от UART		 
						
							/*******Выбираем, что мониторить**********/
							/*	uart_buf[2]=0 - канал "ВХ.30В"
							   	uart_buf[2]=1 - канал "ВХ.360В1"
								uart_buf[2]=2 - канал "ВХ.360В2"
							*/
						if (uart_buf[2]==0) {	array_data[0]=ADC_SPI(1,CS0);		//check U канал "ВХ.30В"
												array_data[1]=ADC_SPI(2,CS0);}		//check I канал "ВХ.30В"
						
						else if (uart_buf[2]==1) {	array_data[0]=ADC_SPI(1,CS3);	//check U канал "ВХ.360В1"
													array_data[1]=ADC_SPI(2,CS3);}	//check I канал "ВХ.360В1"
						
						else if (uart_buf[2]==2) {	array_data[0]=ADC_SPI(1,CS5);	//check U канал "ВХ.360В2"
													array_data[1]=ADC_SPI(2,CS5);}	//check I канал "ВХ.360В2"
							
							/********************ОТВЕТНЫЙ ПАКЕТ ДЛЯ ВЕРХНЕГО УРОВНЯ************************************/
							/*	[STX] 
								[L=11] 
							  	[0] 
								[4 байта U] [4 байта I]
								[CRC]
							*/
					    put_packet(11,&array_data);	//отрыгиваем в УАРТ целый пакет с данными
						
						free (uart_buf); 			//очищаем память под массив
						key_command=0xFF;  			//сброс кода команды
						ES=1;						//снова разрешаем прерывания от UART
						break;
//-------------------------------------------------------------------------------------------------------------------------


//---------------------------------КОНТРОЛЬ УРОВНЯ ПУЛЬСАЦИЙ ПО ВХОДУ ВХ.30В (№6)------------------------------

			case 6:		
						ES=0;					//запрещаем нафик прерывания от UART		 
						
						/***сохраняем 4 байта уставки порога пульс-й в 0-й элемент массива для срача	,long int***/
						
						array_data[0] = 0;	//предварительно обнулим этот четырехбайтовый элемент  [00] [00] [00] [00]
	
						array_data[0] |= (unsigned long int) 	uart_buf[2]<<24; 	// uart_buf[2] -> [x] [] [] []
						array_data[0] |= (unsigned long int)	uart_buf[3]<<16;  	// uart_buf[3] -> [] [x] [] []
						array_data[0] |= (unsigned long int)	uart_buf[4]<<8;   	// uart_buf[4] -> [] [] [x] []
						array_data[0] |= (unsigned long int)	uart_buf[5]<<0;   	// uart_buf[5] -> [] [] [] [x]

						DAC(array_data[0],CS2);		//установим порог пульсаций на компараторе D18
						delay(10); 					//тупо тупанем  для установки ЦАП
						array_data[0]=!P30;			//сохраним инверс.состояние компаратора

							/********************ОТВЕТНЫЙ ПАКЕТ ДЛЯ ВЕРХНЕГО УРОВНЯ************************************/
							/*	[STX] 
								[L=4] 
							  	[0] 
								[1 байт P30]   0-ок, 1-пиздец
								[CRC]
							*/
					    
					    put_packet(4,&array_data);	//отрыгиваем в УАРТ целый пакет с данными
			
						free (uart_buf); 			//очищаем память под массив
						key_command=0xFF;  			//сброс кода команды
						ES=1;						//снова разрешаем прерывания от UART
						break;

//-------------------------------------------------------------------------------------------------------------------------



//---------------------------------УСТАНОВКА НАГРУЗКИ ПО ВХОДАМ "ВХ.30В" "ВХ.360В1" "ВХ.360В2" (№7)------------------------------

			case 7:		
						ES=0;					//запрещаем нафик прерывания от UART		 
						
						/***сохраняем 4 байта уставки тока или мощи в 0-й элемент массива для срача	,long int***/
						
						array_data[0] = 0;	//предварительно обнулим этот четырехбайтовый элемент  [00] [00] [00] [00]
	
						array_data[0] |= (unsigned long int) 	uart_buf[3]<<24; 	// uart_buf[3] -> [x] [] [] []
						array_data[0] |= (unsigned long int)	uart_buf[4]<<16;  	// uart_buf[4] -> [] [x] [] []
						array_data[0] |= (unsigned long int)	uart_buf[5]<<8;   	// uart_buf[5] -> [] [] [x] []
						array_data[0] |= (unsigned long int)	uart_buf[6]<<0;   	// uart_buf[6] -> [] [] [] [x]
							
						/*****в	 array_data[0] лежит либо ток в мкв, либо моща в мкВт.******
						******дальше действуем в зависимости от кода в uart_buf[2] ******** 
						
						/*------если выбрано "установить нагрузку по току по 30В" (1A-1V)--------*/
						if	( uart_buf[2]==0 ) 
							{
								power_30V=0;					//сбросим флаг 30В  
								DAC(array_data[0],CS1);	   		//установка ЦАП 30В (1A-1V)
								array_data[0]=ADC_SPI(1,CS0);	//check U канал "ВХ.30В"
								array_data[1]=ADC_SPI(2,CS0);}	//check I канал "ВХ.30В"
									
						
						/*------если выбрано "установить нагрузку по току по 360В1" (1A-5V)--------*/
						/*Переведем мкА в мкВ ЦАП: array_data[0]*5, ибо (1A-5V), см.MathCad*/
						else if	( uart_buf[2]==1 ) 
							{
								power_360V1=0;					//сбросим флаг 360В1  
								DAC(array_data[0]*5,CS4);	   	//установка ЦАП 360В1 (1A-5V)
								array_data[0]=ADC_SPI(1,CS3);	//check U канал "ВХ.360В1"
								array_data[1]=ADC_SPI(2,CS3);}	//check I канал "ВХ.360В1"
									

						/*------если выбрано "установить нагрузку по току по 360В2" (1A-5V)--------*/
						/*Переведем мкА в мкВ ЦАП: array_data[0]*5, ибо (1A-5V), см.MathCad*/
						else if	( uart_buf[2]==2 ) 
							{
								power_360V2=0;					//сбросим флаг 360В2  
								DAC(array_data[0]*5,CS6);	   	//установка ЦАП 360В2 (1A-5V)
								array_data[0]=ADC_SPI(1,CS5);	//check U канал "ВХ.360В2"
								array_data[1]=ADC_SPI(2,CS5);}	//check I канал "ВХ.360В2"
									
						/*------если выбрано "установить нагрузку по моще по 30В" --------*/
						else if	( uart_buf[2]==3 ) 
							{
								power_30V=1;			//установим флаг 30В  
								power=array_data[0];	/*сохранить знач. мощи в power 
														для дайльнейшей работы после switch*/
								power_DAC (power,uart_buf[2]); //рассчеты и установка мощи
								array_data[0]=ADC_SPI(1,CS0);	//check U канал "ВХ.360В2"
								array_data[1]=ADC_SPI(2,CS0);}	//check I канал "ВХ.360В2"

						/*------если выбрано "установить нагрузку по моще по 360В1" --------*/
						else if	( uart_buf[2]==4 ) 
							{
								power_360V1=1;			//установим флаг 360В1  
								power=array_data[0];	/*сохранить знач. мощи в power 
														для дайльнейшей работы после switch*/
								power_DAC (power,uart_buf[2]); //рассчеты и установка мощи
								array_data[0]=ADC_SPI(1,CS3);	//check U канал "ВХ.360В2"
								array_data[1]=ADC_SPI(2,CS3);}	//check I канал "ВХ.360В2"
							
						/*------если выбрано "установить нагрузку по моще по 360В2" --------*/
						else if	( uart_buf[2]==5 ) 
							{
								power_360V2=1;			//установим флаг 360В1
								power=array_data[0];	/*сохранить знач. мощи в power 
														для дайльнейшей работы после switch*/
								power_DAC (power,uart_buf[2]); //рассчеты и установка мощи
								array_data[0]=ADC_SPI(1,CS5);	//check U канал "ВХ.360В2"
								array_data[1]=ADC_SPI(2,CS5);}	//check I канал "ВХ.360В2"
							
							
							/********************ОТВЕТНЫЙ ПАКЕТ ДЛЯ ВЕРХНЕГО УРОВНЯ************************************/
							/*	[STX] 
								[L=11] 
							  	[0] 
								[4 байта U]   [4 байта I]
								[CRC]
							*/
					    
					    put_packet(11,&array_data);	//отрыгиваем в УАРТ целый пакет с данными
			
						free (uart_buf); 			//очищаем память под массив
						key_command=0xFF;  			//сброс кода команды
						ES=1;						//снова разрешаем прерывания от UART
						break;

/*P.S. Выше, мы можем наблюдать ГОВНОкод. Его можно уменьшить раз в 5, но таким нелепым он
сделан исключительно для лучшей читаемости.*/
//-------------------------------------------------------------------------------------------------------------------------
			



//------------------ИМИТАЦИЯ КОРОТКОГО ЗАМЫКАНИЯ "ВХ.30В" "ВХ.360В1" "ВХ.360В2" (№8)---------------------------------------
/*Перед запуском этой команды желательно снять нагрузку с блока. Может потом не запуститься*/
			case 8:
						ES=0;					//запрещаем нафик прерывания от UART
						
						/*Смотрим, что пришло в байте выбора канала uart_buf[2]*/
						switch (uart_buf[2])
						{
							/*------Вх.30В------*/
							case 0: 
									if (uart_buf[3]==1) {KZ_30V=ON; delay_ms(100);}   	//установить КЗ
									else {KZ_30V=OFF; delay_ms(500);}				   	//снять КЗ
																//тупо тупанем  для установки 
									array_data[0]=ADC_SPI(1,CS0);		//check U канал "ВХ.30В"
									array_data[1]=ADC_SPI(2,CS0);		//check I канал "ВХ.30В"
									break;
							
							/*------Вх.360В1------*/
							case 1: 
									if (uart_buf[3]==1) {KZ_360V1=ON; delay_ms(100);}  //установить КЗ
									else {KZ_360V1=OFF; delay_ms(500);}				//снять КЗ
															//тупо тупанем  для установки 
									array_data[0]=ADC_SPI(1,CS3);		//check U канал "ВХ.30В"
									array_data[1]=ADC_SPI(2,CS3);		//check I канал "ВХ.30В"
									break;

							/*------Вх.360В2------*/
							case 2: 
									if (uart_buf[3]==1) {KZ_360V2=ON; delay_ms(100);}  //установить КЗ
									else {KZ_360V2=OFF; delay_ms(500);}				//снять КЗ
																//тупо тупанем  для установки 
									array_data[0]=ADC_SPI(1,CS5);		//check U канал "ВХ.30В"
									array_data[1]=ADC_SPI(2,CS5);		//check I канал "ВХ.30В"
									break;

							default:	 break;
						}				

							/********************ОТВЕТНЫЙ ПАКЕТ ДЛЯ ВЕРХНЕГО УРОВНЯ************************************/
							/*	[STX] 
								[L=11] 
							  	[0] 
								[4 байта U]	[4 байта I]
								[CRC]
							*/
					    
					    put_packet(11,&array_data);	//отрыгиваем в УАРТ целый пакет с данными
			
						free (uart_buf); 			//очищаем память под массив
						key_command=0xFF;  			//сброс кода команды
						ES=1;						//снова разрешаем прерывания от UART
						break;

//-------------------------------------------------------------------------------------------------------------------------


//---------------------------------УПРАВЛЕНИЕ СОСТОЯНИЕМ ДИСКРЕТНОГО ВЫХОДА (№9)---------------------------------------

			case 9:		
						ES=0;					//запрещаем нафик прерывания от UART		 
						
						if (uart_buf[2] == 0) {DOUT=OFF;}	//разомкнуть
						if (uart_buf[2] == 1) {DOUT=ON;}	//замкнуть

					/********************ОТВЕТНЫЙ ПАКЕТ ДЛЯ ВЕРХНЕГО УРОВНЯ************************************/
							/*	[STX] 
								[L=3] 
							  	[0] 
								[CRC]
							*/
					    
					    put_packet(3,&array_data);	//отрыгиваем в УАРТ целый пакет с данными
			
						free (uart_buf); 			//очищаем память под массив
						key_command=0xFF;  			//сброс кода команды
						ES=1;						//снова разрешаем прерывания от UART
						break;

//-------------------------------------------------------------------------------------------------------------------------


//---------------------------------КОНТРОЛЬ СОСТОЯНИЯ ДИСКРЕТНЫХ ВХОДОВ (№10)---------------------------------------

			case 10:		
						ES=0;					//запрещаем нафик прерывания от UART		 
						
						/*будем хранить состояние 4-х дискретных входов в array_data[0]*/
								/*[DIN1][DIN2][DIN3][DIN4], []-byte*/
								/*0-разомкнут,1-замкнут. Поэтому инверсия !DIN*/
						
						array_data[0]=0;		//занулим
						
						array_data[0] |= (unsigned long int) (!DIN1)<<24;	//DIN1 -> [x][][][]
						array_data[0] |= (unsigned long int) (!DIN2)<<16;	//DIN2 -> [][x][][]
						array_data[0] |= (unsigned long int) (!DIN3)<<8;	//DIN3 -> [][][x][]
						array_data[0] |= (unsigned long int) (!DIN4)<<0;	//DIN4 -> [][][][x]
					
					/********************ОТВЕТНЫЙ ПАКЕТ ДЛЯ ВЕРХНЕГО УРОВНЯ************************************/
							/*	[STX] 
								[L=7] 
							  	[0] 
								[DIN1][DIN2][DIN3][DIN4]
								[CRC]
							*/
					    
					    put_packet(7,&array_data);	//отрыгиваем в УАРТ целый пакет с данными
			
						free (uart_buf); 			//очищаем память под массив
						key_command=0xFF;  			//сброс кода команды
						ES=1;						//снова разрешаем прерывания от UART
						break;

//-------------------------------------------------------------------------------------------------------------------------


			default:	 break;
		
		}	
//-------------------------------------------------------------------------------------------------------------------------




//---------------------------------------ЖИЗНЬ ПОСЛЕ SWITCH----------------------------------------------------------------
		
		
		/*--------------ПОДДЕРЖКА МОЩИ---------------------*/
		/*	ch_power&=0xF9 		[0][0][0][0][0][занулить][занулить][1]
			(ch_power&=0xF9)>>1 [0][0][0][0][0][занулить][1->][занулить]->[0][0][0][0][0][0][0][1]
			(ch_power&=0xFC)>>2 [0][0][0][0][0][1->->][занулить][занулить]->[0][0][0][0][0][0][0][1]

		*/	
		
		if ( power_30V == 1)	power_DAC(power,3);			//30V
		if ( power_360V1 == 1)	power_DAC(power,4);			//360V1
		if ( power_360V2 == 1)	power_DAC(power,5);			//360V2
		

	
	};  //while(1)



} //end main



















//------------------------------ПРЕРЫВАНИЯ--------------------------------

//----------------------T0---------------------------------------
//прерывание по T0. using 1 - используем банк регистров №2,чтобы не испортить остальные

void timer0 (void) interrupt 1 using 1  {
unsigned int  interruptcnt;  
  
  TR0 = 0; //T0 stop
  if (++interruptcnt == 41)  {    /* count to 41 */
    LED=~LED;                       /* инверсия*/
    interruptcnt = 0;               /* clear int counter */
  }
		/*ЗАЩИТА ОТ ПЕРЕГРУЗКИ*/
	
//--------------КАНАЛ 360V1---------------------
//		if ( ADC_SPI( 2,CS3 )>100 )  //если ток в канале > 300 мА, то вырубаем DAC
//		{DAC(0,CS4);}				//значение DAC в 0
//-----------------------------------------------

	TF0 = 0; //сброс флага прерывания
	TR0 = 1; //T0 go
}



//----------------------T2---------------------------------------
//прерывание по T2. using 2 - используем банк регистров №2,чтобы не испортить остальные

void timer2 (void) interrupt 5 using 2  {
  
  
  	TR2 = 0; //T2 stop
  	
	t2counter_ms++;
	
	TF2 = 0; //сброс флага прерывания
	TR2 = 1; //T2 go
}



//----------------------UART---------------------------------------
//uart_buf[L info CTX]

void UART_RX (void) interrupt 4 using 2 
{
	unsigned char i;	
	unsigned int data tmp=0x0000; //сумма для подсчета CRC
	unsigned char L=0,CRC=0; // //L-длина пакета, STX -признак начала пакета (02h) CRC-контрольная сумма

	if (RI==0) goto exit;  	//выходим, если прерывание по передаче
	
	EA = 0; 				// запрещаем все прерывания нафиг

	if (SBUF == STX) //проверка признака начала пакета
	{				 //если STX не 02h, то просто вываливаемся из вектора

		RI=0; //сбрасываем флаг по приему
		while (!RI); /*ждем флаг окончания приема*/

		L = SBUF;	//принимаем длину пакета
		
		
		
		uart_buf=malloc( L*sizeof(char));	 //выделяем память для массива. malloc(кол-во байт)
		
		//если память не получилось выделить, выходим.
		if(!uart_buf) {
			goto exit;
  		}

		uart_buf[0] = L; //сохраняем длину пакета в буфер
		
		RI=0; //сбрасываем флаг по приему
		
		for (i=1;i<L;i++)	  //набиваем буфер в соответствии с L
		{
			while (!RI); /*ждем флаг окончания приема*/
			uart_buf[i]=SBUF;
			RI=0; //сбрасываем флаг по приему
	
		}
	

		/*-------Подсчет контрольной суммы CRC----------*/
// CRC = младший байт (L+info)
//info = uart_buf[1..(N-1)]
		for (i=0;i<(L-1);i++)
		{
			tmp += uart_buf[i]; //сумма значений L+INFO
		}		
		CRC = ( tmp & (~(0xFF00)) ); //зануляем старший байт
		

		/*-------Сравнение контрольной суммы CRC с пришедшей----------*/

		if (uart_buf[L-1]==CRC)  /*ЕСЛИ CRC сошлись, то отправляем маркер подтверждения приема ACK=AAh*/
		{						  
//			SBUF = 0xAA;
//			while (!TI); //Ожидание готовности				 //ОТКЛЮЧЕНО НА ВРЕМЯ ОТЛАДКИ
//			TI = 0;	 //сбрасываем флаг

			key_command = uart_buf[1]; //код команды всегда хранится сразу после L
		}
		else		//ЕСЛИ	 CRC не сошлись, то отправляем маркер  ошибки приема NAK=55h
		{										
			SBUF = NAK;
			while (!TI); //Ожидание готовности
			TI = 0;	 //сбрасываем флаг
		}
	}
	RI=0;//сбрасываем флаг по приему
 exit:
 //free (uart_buf);	 //очищаем предыдущий кусок памяти для массива uart_buf
 EA=1;
}

//----------------------ADC---------------------------------------
//прерывание от ADC
void adc_int() interrupt 6{						/*пока не Юзаем*/
	//printf("%02BX%02BX\n",ADCDATAH,ADCDATAL);
	return;
			  }

//------------------------------КОНЕЦ ПРЕРЫВАНИЯ---------------------------

